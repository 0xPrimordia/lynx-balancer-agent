#!/usr/bin/env node

// Suppress noisy warnings and errors
import './suppress-warnings.js';

import { config } from 'dotenv';
import { ChatOpenAI } from '@langchain/openai';
import { ChatPromptTemplate } from '@langchain/core/prompts';
import { AgentExecutor, createToolCallingAgent } from 'langchain/agents';
import { Client } from '@hashgraph/sdk';
import { HederaLangchainToolkit } from 'hedera-agent-kit';
import { StructuredTool } from '@langchain/core/tools';
// TODO: Re-enable when balance tools are recreated as proper structured tools
// import { contractTransferParameters, contractTransferExecute } from './tools/contract-transfer-tool.js';
// import { BalanceTools } from './tools/balance-tools.js';

// Load environment variables
config();

interface EnvironmentConfig {
  HEDERA_NETWORK?: string;
  HEDERA_ACCOUNT_ID?: string;
  HEDERA_PRIVATE_KEY?: string;
  BALANCER_AGENT_ACCOUNT_ID?: string;
  BALANCER_AGENT_PRIVATE_KEY?: string;
  OPENAI_API_KEY?: string;
  
  // Contract/treasury configurations
  GOVERNANCE_CONTRACT_ID?: string;
  TREASURY_ACCOUNT_ID?: string;
}

/**
 * Custom Tool for Contract Transfers (reused from tool-calling-balance-check)
 * TODO: Re-enable when contract transfer tool is recreated as proper structured tool
 */
/*
class ContractTransferTool extends StructuredTool {
  name = 'contract_transfer';
  description = 'Transfer tokens or HBAR from a contract by calling a contract function';
  schema = contractTransferParameters({});

  constructor(private client: Client) {
    super();
  }

  async _call(input: any): Promise<string> {
    const result = await contractTransferExecute(this.client, {}, input);
    return JSON.stringify(result, null, 2);
  }
}
*/

/**
 * Balancing Test Runner
 * 
 * This script allows manual testing of the balancing logic
 * TODO: Re-enable when balance tools are recreated as proper structured tools
 */
/*
class BalancingTestRunner {
  private hederaAgentToolkit?: HederaLangchainToolkit;
  private agentExecutor?: AgentExecutor;
  private client?: Client;
  private balanceTools?: BalanceTools;
  private env: NodeJS.ProcessEnv & EnvironmentConfig;

  constructor() {
    this.env = process.env as NodeJS.ProcessEnv & EnvironmentConfig;
  }

  /**
   * Initialize the balancing test environment
   */
  async initialize(): Promise<void> {
    console.log("ü¶å‚ö° Initializing Balancing Test Runner");
    console.log("=====================================");

    // Validate required environment variables
    const requiredVars = [
      'HEDERA_ACCOUNT_ID',
      'HEDERA_PRIVATE_KEY',
      'OPENAI_API_KEY',
      'GOVERNANCE_CONTRACT_ID'
    ];
    
    const missingVars = requiredVars.filter(varName => !this.env[varName]);
    if (missingVars.length > 0) {
      throw new Error(`Missing required environment variables: ${missingVars.join(', ')}`);
    }

    try {
      // Initialize Hedera Client
      this.client = Client.forTestnet();
      this.client.setOperator(this.env.HEDERA_ACCOUNT_ID!, this.env.HEDERA_PRIVATE_KEY!);

      // Initialize Hedera Agent Kit
      this.hederaAgentToolkit = new HederaLangchainToolkit({
        client: this.client,
        configuration: {}
      });

      // Initialize OpenAI LLM
      const llm = new ChatOpenAI({
        modelName: "gpt-4o",
        temperature: 0,
        apiKey: this.env.OPENAI_API_KEY,
      });

      // Create the agent prompt template
      const prompt = ChatPromptTemplate.fromMessages([
        ['system', `You are a treasury balancing agent for the Lynx DAO.
        You have access to Hedera blockchain tools that allow you to:
        - Query contract and account balances
        - Transfer HBAR and tokens between accounts and contracts
        - Call contract functions for withdrawals
        
        Current Configuration:
        - Operator Account: ${this.env.HEDERA_ACCOUNT_ID}
        - Governance Contract: ${this.env.GOVERNANCE_CONTRACT_ID}
        - Network: ${this.env.HEDERA_NETWORK || 'testnet'}
        
        Your job is to maintain target portfolio ratios by rebalancing token holdings.
        `],
        ['placeholder', '{chat_history}'],
        ['human', '{input}'],
        ['placeholder', '{agent_scratchpad}'],
      ]);

      // Get Hedera tools and add contract transfer tool
      const hederaTools = this.hederaAgentToolkit.getTools();
      const contractTransferTool = new ContractTransferTool(this.client);
      const allTools = [...hederaTools, contractTransferTool];

      // Create the tool-calling agent
      const agent = await createToolCallingAgent({
        llm,
        tools: allTools,
        prompt
      });
      
      // Create the agent executor
      this.agentExecutor = new AgentExecutor({
        agent,
        tools: allTools,
        verbose: true,
        maxIterations: 10
      });

      // Initialize balance tools
      this.balanceTools = new BalanceTools(
        this.agentExecutor,
        this.hederaAgentToolkit,
        this.client,
        this.env.GOVERNANCE_CONTRACT_ID!,
        this.env.HEDERA_ACCOUNT_ID!
      );

      console.log("‚úÖ Balancing test environment initialized");
      console.log(`üìã Operator Account: ${this.env.HEDERA_ACCOUNT_ID}`);
      console.log(`üèõÔ∏è  Governance Contract: ${this.env.GOVERNANCE_CONTRACT_ID}`);
      console.log(`üîß Loaded ${hederaTools.length + 1} tools`);

    } catch (error) {
      console.error("‚ùå Failed to initialize:", error);
      throw error;
    }
  }

  /**
   * Test current contract balances
   */
  async testGetBalances(): Promise<void> {
    console.log("\nüîç Testing Contract Balance Retrieval");
    console.log("====================================");

    if (!this.balanceTools) {
      throw new Error("Not initialized. Call initialize() first.");
    }

    try {
      const balances = await this.balanceTools.getCurrentContractBalances();
      
      console.log("‚úÖ Contract Balances Retrieved:");
      console.log("==============================");
      for (const [token, balance] of Object.entries(balances)) {
        console.log(`${token}: ${balance}`);
      }

    } catch (error) {
      console.error("‚ùå Failed to get balances:", error);
      throw error;
    }
  }

  /**
   * Test ratio calculations
   */
  async testCalculateRatios(): Promise<void> {
    console.log("\nüìä Testing Ratio Calculations");
    console.log("============================");

    if (!this.balanceTools) {
      throw new Error("Not initialized. Call initialize() first.");
    }

    try {
      // Get current balances first
      const balances = await this.balanceTools.getCurrentContractBalances();
      
      // Calculate ratios
      const ratios = await this.balanceTools.calculateCurrentRatios(balances);
      
      console.log("‚úÖ Current Portfolio Ratios:");
      console.log("===========================");
      for (const [token, ratio] of Object.entries(ratios)) {
        console.log(`${token}: ${(ratio as number).toFixed(2)}%`);
      }

    } catch (error) {
      console.error("‚ùå Failed to calculate ratios:", error);
      throw error;
    }
  }

  /**
   * Test rebalancing analysis with mock governance alert
   */
  async testRebalancingAnalysis(): Promise<void> {
    console.log("\n‚öñÔ∏è  Testing Rebalancing Analysis");
    console.log("===============================");

    if (!this.balanceTools) {
      throw new Error("Not initialized. Call initialize() first.");
    }

    try {
      // Mock governance alert data
      const mockAlert = {
        type: 'BALANCING_ALERT',
        token: 'HBAR',
        currentRatio: 45,
        targetRatio: 40,
        deviation: 5,
        alertLevel: 'MEDIUM',
        reason: 'HBAR ratio exceeded target by 5%'
      };

      // Process the alert
      const result = await this.balanceTools.processGovernanceAlert(mockAlert);
      
      console.log("‚úÖ Rebalancing Analysis Results:");
      console.log("================================");
      console.log(`Success: ${result.success}`);
      console.log(`Summary: ${result.summary}`);

    } catch (error) {
      console.error("‚ùå Failed to analyze rebalancing:", error);
      throw error;
    }
  }

  /**
   * Test full rebalancing workflow with dry run
   */
  async testFullWorkflow(dryRun: boolean = true): Promise<void> {
    console.log(`\nüöÄ Testing Full Rebalancing Workflow ${dryRun ? '(DRY RUN)' : '(LIVE)'}`);
    console.log("================================================================");

    if (!this.balanceTools) {
      throw new Error("Not initialized. Call initialize() first.");
    }

    try {
      // Step 1: Get current balances
      console.log("Step 1: Getting current contract balances...");
      const balances = await this.balanceTools.getCurrentContractBalances();
      
      // Step 2: Calculate current ratios
      console.log("Step 2: Calculating current ratios...");
      const currentRatios = await this.balanceTools.calculateCurrentRatios(balances);
      
      // Step 3: Define target ratios (mock governance decision)
      const targetRatios = {
        HBAR: 40,
        SAUCE: 20,
        LYNX: 15,
        WBTC: 10,
        USDC: 10,
        JAM: 3,
        HEADSTART: 2
      };
      
      console.log("Step 3: Target ratios defined:", targetRatios);
      
      // Step 4: Analyze rebalancing needs
      console.log("Step 4: Analyzing rebalancing needs...");
      const analysis = this.balanceTools.analyzeRebalancingNeeds(currentRatios, targetRatios, 2.0);
      
      if (!analysis.needsRebalancing) {
        console.log("‚úÖ No rebalancing needed - portfolio is within tolerance");
        return;
      }
      
      console.log("üö® Rebalancing needed for the following tokens:");
      for (const [token, adj] of Object.entries(analysis.adjustments)) {
        const adjustment = adj as {current: number, target: number, deviation: number};
        if (adjustment.deviation > 2.0) {
          console.log(`   ${token}: ${adjustment.current.toFixed(2)}% ‚Üí ${adjustment.target.toFixed(2)}% (${adjustment.deviation.toFixed(2)}% deviation)`);
        }
      }
      
      if (dryRun) {
        console.log("üîç DRY RUN: Would execute rebalancing operations here");
        console.log("   Use 'npm run test:balancing live' to execute actual transactions");
      } else {
        // Step 5: Execute rebalancing (LIVE)
        console.log("Step 5: Executing rebalancing operations...");
        const totalValue = 1000; // Placeholder
        const result = await this.balanceTools.executeRebalancing(analysis.adjustments, totalValue);
        
        console.log(`‚úÖ Rebalancing ${result.success ? 'completed' : 'failed'}`);
        console.log("Operations:", result.operations);
      }

    } catch (error) {
      console.error("‚ùå Failed full workflow test:", error);
      throw error;
    }
  }
}
*/

/**
 * Main function
 * TODO: Re-enable when balance tools are recreated as proper structured tools
 */
/*
async function main(): Promise<void> {
  console.log("ü¶å‚ö° Balancing Logic Test Runner");
  console.log("===============================");

  const args = process.argv.slice(2);
  const command = args[0] || 'balances';

  const testRunner = new BalancingTestRunner();

  try {
    await testRunner.initialize();

    switch (command.toLowerCase()) {
      case 'balances':
        await testRunner.testGetBalances();
        break;
      case 'ratios':
        await testRunner.testCalculateRatios();
        break;
      case 'analysis':
        await testRunner.testRebalancingAnalysis();
        break;
      case 'workflow':
        await testRunner.testFullWorkflow(true); // Dry run
        break;
      case 'live':
        await testRunner.testFullWorkflow(false); // Live execution
        break;
      default:
        console.log("üìã Available commands:");
        console.log("  balances   - Test contract balance retrieval");
        console.log("  ratios     - Test ratio calculations");
        console.log("  analysis   - Test rebalancing analysis with mock alert");
        console.log("  workflow   - Test full workflow (dry run)");
        console.log("  live       - Execute full workflow (LIVE transactions)");
        console.log("\nüí° Examples:");
        console.log("   npm run test:balancing balances");
        console.log("   npm run test:balancing ratios");
        console.log("   npm run test:balancing analysis");
        console.log("   npm run test:balancing workflow");
        console.log("   npm run test:balancing live");
        break;
    }

  } catch (error) {
    console.error("‚ùå Failed to run balancing test:", error);
    process.exit(1);
  }
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(console.error);
}
*/ 